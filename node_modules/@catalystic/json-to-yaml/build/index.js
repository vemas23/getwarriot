const trimWhitespace = (input) => {
    return input
        .split("\n")
        .map((x) => x.trimEnd())
        .join("\n");
};
const typeOf = (obj) => {
    const objectType = {}.toString.call(obj);
    const e = objectType.split(" ")[1];
    if (!e)
        return "unknown";
    return e.slice(0, -1).toLowerCase();
};
const typeNotAllowed = (type) => {
    return new Error(`JS Object/JSON with ${type} is not allowed when converting to YAML`);
};
let indentLevel = "";
const handlers = {
    undefined: () => {
        return "null";
    },
    null: () => "null",
    number: (x) => x,
    boolean: (x) => (x ? "true" : "false"),
    string: (x) => {
        return JSON.stringify(x);
    },
    array: (x) => {
        if (x.length === 0)
            return "[]";
        let output = "";
        indentLevel = indentLevel.replace(/$/, "  ");
        for (const y of x) {
            const handler = handlers[typeOf(y)];
            if (!handler) {
                throw new Error(`what the crap: ${typeOf(y)}`);
            }
            output += `\n${indentLevel}- ${handler(y, true)}`;
        }
        indentLevel = indentLevel.replace(/ {2}/, "");
        return output;
    },
    object: (x, inArray, rootNode) => {
        if (Object.keys(x).length === 0)
            return "{}";
        let output = "";
        if (!rootNode)
            indentLevel = indentLevel.replace(/$/, "  ");
        Object.keys(x).forEach((k, i) => {
            const val = x[k];
            const handler = handlers[typeOf(val)];
            if (typeof val === "undefined")
                return;
            if (!handler) {
                throw new Error(`[Corrupt state]: ${typeOf(val)}`);
            }
            if (!(inArray && i === 0))
                output += `\n${indentLevel}`;
            output += `${k}: ${handler(val)}`;
        });
        indentLevel = indentLevel.replace(/ {2}/, "");
        return output;
    },
    function: () => {
        throw typeNotAllowed("Function");
    },
    map: () => {
        throw typeNotAllowed("Map");
    },
    set: () => {
        throw typeNotAllowed("Set");
    },
};
export const convert = (data) => {
    const handler = handlers[typeOf(data)];
    return trimWhitespace(`${handler(data, true, true)}\n`);
};
